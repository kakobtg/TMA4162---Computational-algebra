

# This file was *autogenerated* from the file buchberger.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2)
def buchberger(F):
    """
    Compute a Gröbner basis for an ideal generated by F using Buchberger's algorithm.
    
    Args:
        F: List of polynomials generating the ideal.
    
    Returns:
        G: Gröbner basis for the ideal ⟨F⟩.
    """
    # Initialize
    G = list(F)
    pairs = [(i, j) for i in range(len(G)) for j in range(i + _sage_const_1 , len(G))]
    
    while pairs:
        # Select a pair (i, j)
        i, j = pairs.pop(_sage_const_0 )
        f, g = G[i], G[j]
        
        # Compute S-polynomial (ensuring we stay in polynomial ring)
        lcm_LT = lcm(f.lt(), g.lt())
        S = (lcm_LT // f.lt()) * f - (lcm_LT // g.lt()) * g
        
        # Reduce S modulo G using polynomial division
        r = S
        while True:
            division_occurred = False
            for h in G:
                if h == _sage_const_0 :
                    continue
                if h.lt().divides(r.lt()):
                    quotient = r.lt() // h.lt()  # Use polynomial division
                    r = r - quotient * h
                    division_occurred = True
                    break
            if not division_occurred:
                break
        
        # If remainder r ≠ 0, add to G and update pairs
        if r != _sage_const_0 :
            k = len(G)
            G.append(r)
            pairs.extend((k, l) for l in range(k))
    
    return G

R = PolynomialRing(QQ, order='lex', names=('x', 'y',)); (x, y,) = R._first_ngens(2)
g1 = x**_sage_const_2  * y - y
g2 = x*y**_sage_const_2  - x
I = Ideal([g1, g2])
G = I.groebner_basis()
print("Gröbner basis:", G)

