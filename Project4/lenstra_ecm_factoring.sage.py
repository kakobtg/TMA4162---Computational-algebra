

# This file was *autogenerated* from the file Project4/lenstra_ecm_factoring.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_0 = Integer(0); _sage_const_16 = Integer(16); _sage_const_4 = Integer(4); _sage_const_27 = Integer(27); _sage_const_15 = Integer(15); _sage_const_14 = Integer(14); _sage_const_5000 = Integer(5000); _sage_const_15000 = Integer(15000)
from sage.all import *
from random import randint
from math import gcd


def lenstra_ecm(N, B, max_tries):
    """
    Try to factor N using Lenstra's Elliptic Curve Method (ECM).

    Args:
        N (int): Composite number to factor.
        B (int): Smoothness bound.
        max_tries (int): Number of random curves to try.

    Returns:
        A nontrivial factor of N if found, otherwise None.
    """
    for attempt in range(max_tries):
        # Pick random curve: y^2 = x^3 + a*x + b mod N
        x0 = randint(_sage_const_1 , N - _sage_const_1 )
        y0 = randint(_sage_const_1 , N - _sage_const_1 )
        a = randint(_sage_const_1 , N - _sage_const_1 )
        b = (y0**_sage_const_2  - x0**_sage_const_3  - a * x0) % N

        try:
            E = EllipticCurve(Integers(N), [a, b])
            P = E(x0, y0)
        except (TypeError, ValueError):
            continue  # invalid point or curve

        # Compute k = product of small prime powers up to B
        k = _sage_const_1 
        for p in prime_range(_sage_const_2 , B + _sage_const_1 ):
            e = floor(log(B) / log(p))
            k *= p**e

        print(f"Trying curve {attempt + _sage_const_1 }: y^2 = x^3 + {a}x + {b}, point = ({x0}, {y0})")

        try:
            Q = k * P
        except ZeroDivisionError as e:
            # If division fails inside EC arithmetic, extract GCD
            num = e.args[_sage_const_0 ]
            factor = gcd(num, N)
            if _sage_const_1  < factor < N:
                print(f"Nontrivial factor found: {factor}")
                return factor
            else:
                continue

    print("No factor found after trying all curves.")
    return None

def lenstra_ecm_fast(N, B, max_tries):
    primes = list(prime_range(_sage_const_2 , B + _sage_const_1 ))
    k = _sage_const_1 
    for p in primes:
        e = floor(log(B) / log(p))
        k *= p**e

    for attempt in range(max_tries):
        while True:
            x0 = randint(_sage_const_1 , N - _sage_const_1 )
            y0 = randint(_sage_const_1 , N - _sage_const_1 )
            a = randint(_sage_const_1 , N - _sage_const_1 )
            b = (y0**_sage_const_2  - x0**_sage_const_3  - a * x0) % N

            # Compute discriminant
            Delta = (-_sage_const_16 ) * (_sage_const_4  * a**_sage_const_3  + _sage_const_27  * b**_sage_const_2 ) % N
            g = gcd(Delta, N)

            if _sage_const_1  < g < N:
                print(f"✅ Found factor from discriminant: {g}")
                return g

            if g != _sage_const_1 :
                continue  # bad discriminant, retry

            try:
                E = EllipticCurve(Integers(N), [a, b])
                P = E(x0, y0)
                break
            except (TypeError, ValueError, ArithmeticError):
                continue  # invalid curve or point, retry

        try:
            Q = k * P
        except ZeroDivisionError:
            print(f"⚠ ZeroDivisionError on attempt {attempt + _sage_const_1 } — skipping curve.")
            continue

    print("❌ No factor found after all attempts.")
    return None

if __name__ == "__main__":
    # Example usage
    #N = 1238926361552897 * 93461639715357977769163558199606896584051237541638188580280321  # F_8 Fermat number
    # factor = lenstra_ecm(N, B=1000, max_tries=50)
    # print(f"Found factor: {factor}")

    # Test with a smaller composite number
    #N = 595945676543  # Example: 59 * 101
    p = random_prime(_sage_const_2 **_sage_const_15 , lbound=_sage_const_2 **_sage_const_14 )
    q = random_prime(_sage_const_2 **_sage_const_15 , lbound=_sage_const_2 **_sage_const_14 )
    N = p * q
    #fac = lenstra_ecm(N, B=5000, max_tries=15000)
    factor = lenstra_ecm_fast(N, B=_sage_const_5000 , max_tries=_sage_const_15000 )
    if factor:
        print(f"Final result: {factor} * {N // factor} = {N}")  # Should print the factor and its cofactor

